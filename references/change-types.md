# 变更类型分类指南

## 变更类型决策树

```
代码变更发生
     │
     ▼
是否修复了 Bug？ ──Yes──► BUG_FIX
     │ No
     ▼
是否改变了功能行为？ ──Yes──► BEHAVIOR_CHANGE
     │ No
     ▼
是否修改了数据结构？ ──Yes──► DATA_STRUCTURE
     │ No
     ▼
是否修改了 API 接口？ ──Yes──► API_CHANGE
     │ No
     ▼
是否为性能优化？ ──Yes──► PERFORMANCE
     │ No
     ▼
是否为紧急修复？ ──Yes──► HOTFIX
     │ No
     ▼
OTHER（记录但不强制更新 spec）
```

## 详细分类标准

### BUG_FIX (Bug 修复)

**识别特征**:
- 修复了逻辑错误
- 修复了边界条件处理
- 修复了异常未捕获
- 修复了数据处理错误

**Spec 更新点**:
- 在 Change Log 中记录
- 如果 Bug 暴露了需求描述的歧义，考虑澄清需求文档

**示例**:
```
- 修复文件上传时的编码问题
- 修复分块时的边界条件判断
- 修复空数组导致的崩溃
```

---

### BEHAVIOR_CHANGE (行为变更)

**识别特征**:
- 改变了输入/输出的处理方式
- 改变了默认值
- 改变了业务规则
- 添加/移除了某个功能特性

**Spec 更新点**:
- 更新 spec.md 中相关的功能描述
- 更新 tasks.md 中的任务状态
- **强烈建议创建 ADR**

**示例**:
```
- 将默认分块大小从 500 改为 1000
- 添加了智能分块策略
- 移除了对旧格式的支持
```

---

### DATA_STRUCTURE (数据结构变更)

**识别特征**:
- 修改了数据库 Schema
- 修改了 API 请求/响应模型
- 修改了内部数据结构
- 添加/删除了字段

**Spec 更新点**:
- 更新 data-model.md
- 如果影响 API，同时更新 api.md
- **强烈建议创建 ADR**

**示例**:
```
- 在 Document 表中添加 processed_at 字段
- 修改 ChunkResult 的结构
- 重构了配置文件格式
```

---

### API_CHANGE (API 变更)

**识别特征**:
- 添加了新的 API 端点
- 修改了现有端点的路径/方法
- 修改了请求参数
- 修改了响应格式

**Spec 更新点**:
- 更新 api.md
- 如果影响前端，检查是否需要更新 UI 相关文档
- **强烈建议创建 ADR**

**示例**:
```
- 添加 /api/v1/documents/batch 批量处理接口
- 将 GET 改为 POST
- 添加了分页参数
```

---

### PERFORMANCE (性能优化)

**识别特征**:
- 优化了算法复杂度
- 添加了缓存
- 优化了数据库查询
- 减少了 I/O 操作

**Spec 更新点**:
- 在 Change Log 中记录
- 如果涉及架构变化，考虑创建 ADR

**示例**:
```
- 添加文档解析结果缓存
- 优化向量搜索算法
- 批量处理替代逐条处理
```

---

### HOTFIX (紧急修复)

**识别特征**:
- 生产环境紧急问题
- 安全漏洞修复
- 关键功能故障修复

**Spec 更新点**:
- 在 Change Log 中记录，标注 `[HOTFIX]` 和优先级
- 后续需要补充完整的变更分析

**示例**:
```
- [HOTFIX][P0] 修复内存泄漏导致服务崩溃
- [HOTFIX][P1] 修复 SQL 注入漏洞
```

## 复合变更处理

当一次变更涉及多种类型时：

1. **主类型优先**: 选择影响最大的类型作为主类型
2. **附加标签**: 在描述中标注其他涉及的类型
3. **分别更新**: 每种类型对应的 spec 文件都需要更新

**示例**:
```markdown
| 日期 | 类型 | 变更内容 | 影响需求 |
|------|------|----------|----------|
| 2026-01-30 | BEHAVIOR_CHANGE + DATA_STRUCTURE | 重构分块策略，添加 chunk_method 字段 | REQ-002-01, REQ-002-03 |
```
